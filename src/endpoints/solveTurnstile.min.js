const fs = require("fs")

module.exports = function solveTurnstileMin({ url, proxy, siteKey }) {
  return new Promise(async (resolve, reject) => {
    if (!url) return reject("Missing url parameter")
    if (!siteKey) return reject("Missing siteKey parameter")

    const context = await global.browser
      .createBrowserContext({
        proxyServer: proxy ? `http://${proxy.host}:${proxy.port}` : undefined
      })
      .catch(() => null)

    if (!context) return reject("Failed to create browser context")

    let isResolved = false
    const timeout = global.timeOut || 60000

    const timer = setTimeout(async () => {
      if (!isResolved) {
        await context.close().catch(() => {})
        reject("Timeout Error")
      }
    }, timeout)

    try {
      const page = await context.newPage()

      if (proxy?.username && proxy?.password) {
        await page.authenticate({
          username: proxy.username,
          password: proxy.password
        })
      }

      await page.setRequestInterception(true)

      const fakePage = fs.readFileSync("./src/data/fakePage.html", "utf8").replace(/<site-key>/g, siteKey)

      page.on("request", async (request) => {
        const reqUrl = request.url()
        if (
          [url, url + "/"].includes(reqUrl) &&
          request.resourceType() === "document"
        ) {
          await request.respond({
            status: 200,
            contentType: "text/html",
            body: fakePage
          })
        } else {
          await request.continue()
        }
      })

      await page.goto(url, { waitUntil: "domcontentloaded" })

      await page.waitForSelector('[name="cf-response"]', { timeout })

      const token = await page.evaluate(() => {
        const el = document.querySelector('[name="cf-response"]')
        return el?.value || null
      })

      isResolved = true
      clearTimeout(timer)
      await context.close().catch(() => {})

      if (!token || token.length < 10) return reject("Failed to get token")
      resolve(token)

    } catch (err) {
      if (!isResolved) {
        clearTimeout(timer)
        await context.close().catch(() => {})
        reject(err.message)
      }
    }
  })
}
